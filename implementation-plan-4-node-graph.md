# å®Ÿè£…è¨ˆç”»4: ãƒãƒ¼ãƒ‰å½¢å¼UIç‰ˆï¼ˆObsidiané¢¨ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ï¼‰

# ParallelLean - ã‚³ã‚¢ã‚¢ã‚¤ãƒ‡ã‚¢

## æ¦‚è¦
å€‹äººãŒãƒªãƒ¼ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã‚’ä¸¦åˆ—ã§è¡Œã†ã®ã‚’ã‚µãƒãƒ¼ãƒˆã™ã‚‹webã‚¢ãƒ—ãƒªParallelLeanã‚’é–‹ç™ºã—ãŸã„ã§ã™ã€‚

AIã®ç™ºé”ã«ã‚ˆã‚Šå€‹äººãŒãƒ­ãƒ¼ã‚³ã‚¹ãƒˆã§è‡ªèº«ã®äº‹æ¥­ã‚’æŒã¤ã“ã¨ãŒã§ãã‚‹æ™‚ä»£ãŒæ¥ã¦ã„ã¾ã™ã€‚ã“ã®æ™‚ä»£ã«æœ€é©ãªãƒªãƒ¼ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã®æ‰‹æ³•ã‚’å¯è¦–åŒ–ã—ã€ã‹ã¤ã‚²ãƒ¼ãƒŸãƒ•ã‚£ã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹UIã‚’æä¾›ã™ã‚‹ã“ã¨ã§ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒãƒ“ã‚¸ãƒã‚¹ã‚’é›£ã—ãè€ƒãˆãšã«ã€è‡ªèº«ã®åå…¥æºã‚’æ¥½ã—ãå¢—ã‚„ã™ã“ã¨ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚

## ãƒªãƒ¼ãƒ³ã‚¹ã‚¿ãƒ¼ãƒˆã‚¢ãƒƒãƒ—ã¨ã¯
ã‚³ã‚¹ãƒˆã‚’ã‹ã‘ãšã«æœ€ä½é™ã®è£½å“ãƒ»ã‚µãƒ¼ãƒ“ã‚¹ãƒ»æ©Ÿèƒ½ã‚’æŒã£ãŸè©¦ä½œå“ã‚’çŸ­æœŸé–“ã§ã¤ãã‚Šã€é¡§å®¢ã®åå¿œã‚’çš„ç¢ºã«å–å¾—ã—ã¦ã€é¡§å®¢ãŒã‚ˆã‚Šæº€è¶³ã§ãã‚‹è£½å“ãƒ»ã‚µãƒ¼ãƒ“ã‚¹ã‚’é–‹ç™ºã—ã¦ã„ããƒãƒã‚¸ãƒ¡ãƒ³ãƒˆæ‰‹æ³•ã§ã™ã€‚æ§‹ç¯‰ãƒ»è¨ˆæ¸¬ãƒ»å­¦ç¿’ã¾ãŸã¯å†æ§‹ç¯‰ã®ã‚¹ãƒ†ãƒƒãƒ—ãŒæå”±ã•ã‚Œã¦ã„ã¾ã™ã€‚

- **æ§‹ç¯‰**: ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’å…ƒã«è£½å“ã‚‚ã—ãã¯ã‚µãƒ¼ãƒ“ã‚¹ã®ä¼ç”»ã‚’ä½œæˆã—ã€MVPã‚’ä½œæˆ
- **è¨ˆæ¸¬**: ã‚¢ãƒ¼ãƒªãƒ¼ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã«æä¾›ã—åå¿œã‚’è¦‹ã‚‹
- **å­¦ç¿’**: è¨ˆæ¸¬ã§ã®çµæœã‚’å…ƒã«MVPã‚’æ”¹å–„ã—ã¦ã„ãã€ä¸€èˆ¬é¡§å®¢ã«å—ã‘å…¥ã‚Œã¦ã‚‚ã‚‰ãˆã‚‹å½¢ã¨ã—ã¦çµ„ã¿ç›´ã—ã¦ã„ã
- **å†æ§‹ç¯‰**: å­¦ç¿’ã«ã‚ˆã‚‹ã‚ã‚‹ç¨‹åº¦ã®å¾®èª¿æ•´ã§ã¯ãªãã€å¤§å¹…ãªä¿®æ­£ãŒå¿…è¦ã¨åˆ¤æ–­ã•ã‚ŒãŸå ´åˆã«ã€äº‹æ¥­ã‚’å†æ§‹ç¯‰ã™ã‚‹ã“ã¨ã€‚

## åŸºæœ¬çš„ãªæµã‚Œ

### 1. ã‚¹ãƒˆãƒƒã‚¯
ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªèº«ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’ãƒ¡ãƒ¢ã®ã‚ˆã†ãªå½¢ã§ç°¡æ½”ã«æ›¸ãã€ãã‚Œã‚’ã‚¹ãƒˆãƒƒã‚¯ã—ã¦ãŠãã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãã®ã‚¹ãƒˆãƒƒã‚¯ã®ä¸­ã‹ã‚‰MVPã¨ã—ã¦ä½œæˆã—ãŸã„ã‚¢ã‚¤ãƒ‡ã‚¢ã‚’é¸ã³ã¾ã™ã€‚

### 2. æ§‹ç¯‰
é¸ã°ã‚ŒãŸã‚¢ã‚¤ãƒ‡ã‚¢ã¯æ§‹ç¯‰æ®µéšã«å…¥ã‚Šã¾ã™ã€‚ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã“ã®ã‚¢ã‚¤ãƒ‡ã‚¢ã«å¯¾ã—ä¼ç”»æ›¸ã‚’æ›¸ãã€ã‚¢ã‚¤ãƒ‡ã‚¢ã«ãƒªãƒ³ã‚¯ã•ã›ã¾ã™ã€‚ãã†ã™ã‚‹ã¨ã‚¢ã‚¤ãƒ‡ã‚¢ã«ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒå‡ºç¾ã—ã€ã“ã“ã«ã¯MVPé–‹ç™ºã«å¿…è¦ãªToDoãƒªã‚¹ãƒˆãŒã€ãã‚Œãã‚Œã®ã‚¿ã‚¹ã‚¯ã®ä¾å­˜é–¢ä¿‚ãªã©å«ã‚ã¦è¨˜è¿°ã•ã‚Œã¾ã™ã€‚

### 3. è¨ˆæ¸¬
MVPãŒå®Œæˆã™ã‚‹ã¨ã€ã‚¢ã‚¤ãƒ‡ã‚¢ã¯äº‹æ¥­ã¨ãªã‚Šã€äº‹æ¥­ã¯è¨ˆæ¸¬æ®µéšã«å…¥ã‚Šã¾ã™ã€‚äº‹æ¥­ã«ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æˆ¦ç•¥ã¨KPIãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ãŒãƒªãƒ³ã‚¯ã•ã‚Œã¾ã™ã€‚ãƒãƒ¼ã‚±ãƒ†ã‚£ãƒ³ã‚°æˆ¦ç•¥ã«ã¯ä¸»ã«ã‚¢ãƒ¼ãƒªãƒ¼ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã¸ã®ãƒªãƒ¼ãƒæˆ¦ç•¥ã®å…·ä½“çš„ãªæ‰‹æ³•ãŒè¨˜è¿°ã•ã‚Œã¾ã™ã€‚KPIãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«ã¯è¨ˆæ¸¬ã—ãŸKPIã‚’å¯è¦–åŒ–ã—ãŸã‚°ãƒ©ãƒ•ã‚„è¡¨ãªã©ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚

### 4. å­¦ç¿’
è¨ˆæ¸¬æ®µéšã«å…¥ã£ã¦ã‹ã‚‰ä¸€å®šæœŸé–“çµŒã¤ã¨ã€äº‹æ¥­ã¯å­¦ç¿’æ®µéšã«å…¥ã‚Šã¾ã™ã€‚äº‹æ¥­ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¤ãƒ³ã‚µã‚¤ãƒˆã¨æ”¹å–„ç‚¹ãƒªã‚¹ãƒˆãŒãƒªãƒ³ã‚¯ã•ã‚Œã¾ã™ã€‚ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚¤ãƒ³ã‚µã‚¤ãƒˆã¯è¨ˆæ¸¬æ®µéšã§ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã‚ã£ãŸã‚¢ãƒ¼ãƒªãƒ¼ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã«é–¢ã™ã‚‹ã‚¤ãƒ³ã‚µã‚¤ãƒˆã‚’å«ã¿ã€ä»Šå¾Œã“ã®äº‹æ¥­ãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¨ã—ã¦ã„ãä¸€èˆ¬é¡§å®¢åƒã®ãƒ’ãƒ³ãƒˆã«ãªã‚Šã¾ã™ã€‚æ”¹å–„ç‚¹ãƒªã‚¹ãƒˆã¯ãã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå±¤ã‚’å¿µé ­ã«ç½®ã„ãŸã†ãˆã§æ”¹å–„ã™ã‚‹ã¹ãç‚¹ã‚’ãƒªã‚¹ãƒˆã«ã—ãŸã‚‚ã®ã§ã™ã€‚

### 5. å†æ§‹ç¯‰ãƒ»æ’¤é€€
å­¦ç¿’æ®µéšã§äº‹æ¥­ãŒå¤§ããªå•é¡Œã‚’ã¯ã‚‰ã‚“ã§ã„ã‚‹ã“ã¨ãŒç™ºè¦šã—ãŸå ´åˆã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ãã®äº‹æ¥­ã‚’å†æ§‹ç¯‰ã™ã‚‹ã‹ã€æ’¤é€€ã™ã‚‹ã‹é¸ã¶ã“ã¨ãŒã§ãã¾ã™ã€‚ã©ã¡ã‚‰ã«ã›ã‚ˆã€ä»Šå¾Œã®æ´»å‹•ã«æœ‰ç”¨ãªãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦ã€ã“ã®äº‹æ¥­ã®ä»Šã¾ã§ã®æ­©ã¿ã‚’ãƒ¬ãƒãƒ¼ãƒˆã¨ã—ã¦ã¾ã¨ã‚ã€ä¿å­˜ã—ã¾ã™ã€‚

---

# ParallelLean å…±é€šãƒ‡ã‚¶ã‚¤ãƒ³æ–¹é‡

## å…±é€šãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ†ãƒ¼ãƒï¼šç™½é»’ãƒ¢ãƒ€ãƒ³

ã™ã¹ã¦ã®å®Ÿè£…è¨ˆç”»ã«ãŠã„ã¦ã€ä»¥ä¸‹ã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ†ãƒ¼ãƒã‚’å³å®ˆã—ã¾ã™ï¼š

### ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
- **èƒŒæ™¯**: #FFFFFF, #FAFAFA, #F5F5F5
- **ãƒ†ã‚­ã‚¹ãƒˆ**: #000000, #1A1A1A, #333333, #666666
- **ãƒœãƒ¼ãƒ€ãƒ¼**: #E0E0E0, #D0D0D0, #C0C0C0
- **ã‚¢ã‚¯ã‚»ãƒ³ãƒˆ**: #000000ï¼ˆãƒ›ãƒãƒ¼æ™‚ã¯#333333ï¼‰
- **å½±**: rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.05)

### ãƒ‡ã‚¶ã‚¤ãƒ³åŸå‰‡
- **ãƒŸãƒ‹ãƒãƒªã‚ºãƒ **: ä¸è¦ãªè£…é£¾ã‚’æ’é™¤ã—ã€æ©Ÿèƒ½ç¾ã‚’è¿½æ±‚
- **ä½™ç™½ã®æ´»ç”¨**: ååˆ†ãªä½™ç™½ã§æ´—ç·´ã•ã‚ŒãŸå°è±¡ã‚’æ¼”å‡º
- **ã‚¿ã‚¤ãƒã‚°ãƒ©ãƒ•ã‚£**: Silka-Mono Regular ã‚’ä¸»è¦ãƒ•ã‚©ãƒ³ãƒˆã¨ã—ã¦ä½¿ç”¨
- **ãƒ¢ãƒãƒˆãƒ¼ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³**: è‰²ã§ã¯ãªãã€å‹•ãã¨é€æ˜åº¦ã§è¡¨ç¾
- **ã‚·ãƒ£ãƒ¼ãƒ—ãªã‚¨ãƒƒã‚¸**: è§’ä¸¸ã¯æœ€å°é™ï¼ˆ0-4pxï¼‰ã«æŠ‘ãˆã‚‹

### ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³åŸºæœ¬åŸå‰‡
- **ãƒ›ãƒãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ**: å½±ã®å¼·èª¿ã€é€æ˜åº¦ã®å¤‰åŒ–
- **ãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³**: 200-300msã®ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°
- **ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«å¯¾ã™ã‚‹å³åº§ã®è¦–è¦šçš„å¿œç­”
- **ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£**: é«˜ã‚³ãƒ³ãƒˆãƒ©ã‚¹ãƒˆã§WCAG AAæº–æ‹ 

### ã‚¢ã‚¤ã‚³ãƒ³ãƒ»ã‚¤ãƒ©ã‚¹ãƒˆ
- **ãƒ©ã‚¤ãƒ³ã‚¢ã‚¤ã‚³ãƒ³**: ç´°ã‚ã®ã‚¹ãƒˆãƒ­ãƒ¼ã‚¯ï¼ˆ1-2pxï¼‰
- **ãƒ”ã‚¯ãƒˆã‚°ãƒ©ãƒ **: ã‚·ãƒ³ãƒ—ãƒ«ã§èªè­˜ã—ã‚„ã™ã„å½¢çŠ¶
- **ã‚¤ãƒ©ã‚¹ãƒˆ**: ç·šç”»ã‚¹ã‚¿ã‚¤ãƒ«ã¾ãŸã¯ã‚·ãƒ«ã‚¨ãƒƒãƒˆ

## å„å®Ÿè£…è¨ˆç”»ã§ã®å·®åˆ¥åŒ–

ã“ã®å…±é€šãƒ†ãƒ¼ãƒã‚’ç¶­æŒã—ãªãŒã‚‰ã€å„å®Ÿè£…è¨ˆç”»ã§ã¯ä»¥ä¸‹ã®ç‚¹ã§å€‹æ€§ã‚’å‡ºã—ã¾ã™ï¼š

1. **UIãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ**: ã‚«ãƒ³ãƒãƒ³ã€ã‚°ãƒ©ãƒ•ã€ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãªã©
2. **æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯**: ç•°ãªã‚‹ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ãƒ»ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®çµ„ã¿åˆã‚ã›
3. **ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³**: å„UIã«æœ€é©åŒ–ã•ã‚ŒãŸæ“ä½œæ€§
4. **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³**: UIã‚³ãƒ³ã‚»ãƒ—ãƒˆã«å¿œã˜ãŸå‹•ãã®æ¼”å‡º
5. **æƒ…å ±å¯†åº¦**: ç”¨é€”ã«å¿œã˜ãŸè¡¨ç¤ºæƒ…å ±ã®èª¿æ•´

å‹•çš„ã§ã€ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã€ã‚»ãƒ³ã‚¹ã®ã‚ã‚‹ãƒ‡ã‚¶ã‚¤ãƒ³ãŒæ±‚ã‚ã‚‰ã‚Œã¾ã™ã€‚éŠã‚“ã§ãã ã•ã„ã€‚

---

# TDDãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…±é€šåŸå‰‡

## t-wadaã•ã‚“ã®TDDæ‰‹æ³•ã«ã¤ã„ã¦

### åŸºæœ¬ã‚µã‚¤ã‚¯ãƒ«ï¼šRED â†’ GREEN â†’ REFACTOR

1. **REDï¼ˆå¤±æ•—ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’æ›¸ãï¼‰**
   - ã¾ãšå¤±æ•—ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
   - ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹
   - ã“ã®æ®µéšã§å®Ÿè£…ã¯ã¾ã å­˜åœ¨ã—ãªã„

2. **GREENï¼ˆãƒ†ã‚¹ãƒˆã‚’é€šã™ï¼‰**
   - æœ€å°é™ã®å®Ÿè£…ã§ãƒ†ã‚¹ãƒˆã‚’é€šã™
   - ä»®å®Ÿè£…ï¼ˆãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ï¼‰ã‹ã‚‰å§‹ã‚ã¦ã‚‚è‰¯ã„
   - ã¨ã«ã‹ããƒ†ã‚¹ãƒˆã‚’é€šã™ã“ã¨ã«é›†ä¸­

3. **REFACTORï¼ˆãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ï¼‰**
   - ãƒ†ã‚¹ãƒˆãŒé€šã£ã¦ã„ã‚‹çŠ¶æ…‹ã‚’ç¶­æŒã—ãªãŒã‚‰
   - ã‚³ãƒ¼ãƒ‰ã®é‡è¤‡ã‚’é™¤å»
   - è¨­è¨ˆã‚’æ”¹å–„

### TDDã®é»„é‡‘å¾‹

> ã€Œå¤±æ•—ã™ã‚‹ãƒ†ã‚¹ãƒˆãŒãªã„é™ã‚Šã€ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã„ã¦ã¯ã„ã‘ãªã„ã€

### TODOãƒªã‚¹ãƒˆé§†å‹•é–‹ç™º

1. **æœ€åˆã«TODOãƒªã‚¹ãƒˆã‚’ä½œæˆ**
   - å®Ÿè£…ã™ã¹ãæ©Ÿèƒ½ã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
   - å„é …ç›®ã¯15åˆ†ä»¥å†…ã§å®Ÿè£…ã§ãã‚‹ç²’åº¦ã«åˆ†è§£
   - å„ªå…ˆé †ä½ã‚’æ±ºå®š

2. **ä¸€ã¤ãšã¤æ½°ã—ã¦ã„ã**
   - TODOãƒªã‚¹ãƒˆã®é …ç›®ã‚’ä¸€ã¤é¸ã¶
   - ãã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
   - å®Ÿè£…ã™ã‚‹
   - ãƒã‚§ãƒƒã‚¯ãƒãƒ¼ã‚¯ã‚’ä»˜ã‘ã‚‹

### ä»®å®Ÿè£…ã®ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯

```typescript
// æœ€åˆã®å®Ÿè£…ï¼ˆä»®å®Ÿè£…ï¼‰
function add(a: number, b: number): number {
  return 3; // ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°
}

// ãƒ†ã‚¹ãƒˆãŒé€šã£ãŸã‚‰ã€å¾ã€…ã«ä¸€èˆ¬åŒ–
function add(a: number, b: number): number {
  return a + b; // æœ¬å®Ÿè£…
}
```

### ä¸‰è§’æ¸¬é‡

è¤‡æ•°ã®å…·ä½“ä¾‹ã‹ã‚‰ä¸€èˆ¬åŒ–ã‚’å°ãï¼š
1. ä¸€ã¤ç›®ã®å…·ä½“ä¾‹ã§ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
2. ä»®å®Ÿè£…ã§é€šã™
3. äºŒã¤ç›®ã®å…·ä½“ä¾‹ã§ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
4. ä¸€èˆ¬åŒ–ã—ãŸå®Ÿè£…ã«å¤‰æ›´

### å°ã•ãªã‚¹ãƒ†ãƒƒãƒ—

- ä¸€åº¦ã«å¤§ããªå¤‰æ›´ã‚’ã—ãªã„
- å¸¸ã«ãƒ†ã‚¹ãƒˆãŒé€šã‚‹çŠ¶æ…‹ã‚’ç¶­æŒ
- 5åˆ†ä»¥ä¸Šãƒ†ã‚¹ãƒˆãŒé€šã‚‰ãªã„çŠ¶æ…‹ãŒç¶šã„ãŸã‚‰ã€å…ƒã«æˆ»ã™

## ParallelLeanã§ã®é©ç”¨

### å„ãƒ•ã‚§ãƒ¼ã‚ºã®æ„å‘³

1. **Phase 1: ç’°å¢ƒæ§‹ç¯‰**
   - ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®åŸºç›¤ä½œã‚Š
   - æœ€åˆã®ãƒ†ã‚¹ãƒˆã§ç’°å¢ƒãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª

2. **Phase 2-3: ãƒ¢ãƒ‡ãƒ«ã¨ã‚¹ãƒˆã‚¢**
   - ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã®ä¸­æ ¸
   - ç´”ç²‹é–¢æ•°ã¨ã—ã¦å®Ÿè£…ã—ã‚„ã™ã„éƒ¨åˆ†ã‹ã‚‰å§‹ã‚ã‚‹

3. **Phase 4-6: UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ**
   - ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
   - è¦‹ãŸç›®ã‚ˆã‚ŠæŒ¯ã‚‹èˆã„ã‚’ãƒ†ã‚¹ãƒˆ

4. **Phase 7-8: æœ€é©åŒ–ã¨ç‰¹æ®Šæ©Ÿèƒ½**
   - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°
   - ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯å›ºæœ‰ã®æ©Ÿèƒ½

5. **Phase 9-10: çµ±åˆã¨ãƒ‡ãƒ—ãƒ­ã‚¤**
   - E2Eãƒ†ã‚¹ãƒˆã§å…¨ä½“ã®å‹•ä½œç¢ºèª
   - æœ¬ç•ªç’°å¢ƒã¸ã®æº–å‚™

### ãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹ã®ä½¿ã„æ–¹

- [ ] æœªç€æ‰‹ï¼šã¾ã å§‹ã‚ã¦ã„ãªã„
- [x] å®Œäº†ï¼šãƒ†ã‚¹ãƒˆãŒé€šã‚Šã€å®Ÿè£…ãŒå®Œäº†
- [~] ä½œæ¥­ä¸­ï¼šç¾åœ¨å–ã‚Šçµ„ã‚“ã§ã„ã‚‹ï¼ˆGitHubã§ã¯å–ã‚Šæ¶ˆã—ç·šï¼‰

### ãƒ†ã‚¹ãƒˆé§†å‹•ã®åˆ©ç‚¹

1. **è¨­è¨ˆã®æ”¹å–„**
   - ãƒ†ã‚¹ãƒˆã—ã‚„ã™ã„ã‚³ãƒ¼ãƒ‰ã¯è‰¯ã„è¨­è¨ˆ
   - ç–çµåˆã§å‡é›†åº¦ã®é«˜ã„ã‚³ãƒ¼ãƒ‰

2. **ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³é˜²æ­¢**
   - æ—¢å­˜æ©Ÿèƒ½ã‚’å£Šã•ãªã„å®‰å¿ƒæ„Ÿ
   - ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ã®è‡ªç”±åº¦

3. **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆåŒ–**
   - ãƒ†ã‚¹ãƒˆãŒä»•æ§˜æ›¸ã®å½¹å‰²
   - ä½¿ã„æ–¹ã®å®Ÿä¾‹

4. **é–‹ç™ºãƒªã‚ºãƒ **
   - REDâ†’GREENâ†’REFACTORã®ãƒªã‚ºãƒ 
   - é”æˆæ„Ÿã®ç¶™ç¶šçš„ãªç²å¾—

### æ³¨æ„ç‚¹

- ãƒ†ã‚¹ãƒˆã®ãŸã‚ã®ãƒ†ã‚¹ãƒˆã¯æ›¸ã‹ãªã„
- 100%ã®ã‚«ãƒãƒ¬ãƒƒã‚¸ã‚’ç›®æŒ‡ã•ãªã„ï¼ˆ80%ã§ååˆ†ï¼‰
- E2Eãƒ†ã‚¹ãƒˆã¯å¿…è¦æœ€å°é™ã«
- ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆã‚’ä¸­å¿ƒã«ã€çµ±åˆãƒ†ã‚¹ãƒˆã§è£œå®Œ

### å‚è€ƒè³‡æ–™

- ã€Œãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™ºã€Kent Beckè‘—
- ã€Œå®Ÿè·µãƒ†ã‚¹ãƒˆé§†å‹•é–‹ç™ºã€Steve Freeman, Nat Pryceè‘—
- t-wadaã•ã‚“ã®è¬›æ¼”è³‡æ–™ãƒ»ãƒ–ãƒ­ã‚°è¨˜äº‹

---

## æ¦‚è¦
ã‚¢ã‚¤ãƒ‡ã‚¢ã¨äº‹æ¥­ã®é–¢ä¿‚æ€§ã‚’3Dç©ºé–“ã®ãƒãƒ¼ãƒ‰ã‚°ãƒ©ãƒ•ã¨ã—ã¦è¡¨ç¾ã—ã€Obsidianã®ã‚ˆã†ãªç›´æ„Ÿçš„ãªãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ã¨æ¢ç´¢ã‚’å¯èƒ½ã«ã™ã‚‹UIã€‚

## æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: SvelteKit
- **UIãƒ©ã‚¤ãƒ–ãƒ©ãƒª**: Ant Design (antd-svelte) + custom CSS
- **çŠ¶æ…‹ç®¡ç†**: MobX
- **3Dã‚°ãƒ©ãƒ•ãƒ©ã‚¤ãƒ–ãƒ©ãƒª**: Three.js + react-force-graph
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: Supabase
- **ãƒ†ã‚¹ãƒˆ**: Playwright + Vitest
- **å‹å®‰å…¨æ€§**: TypeScript + Superstruct

## UIè¨­è¨ˆ

### ãƒ¡ã‚¤ãƒ³ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ParallelLean                    âš™ï¸ View â–¼  ğŸ” Search  + Node â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                             â”‚
â”‚                     â—‹ idea-5                                â”‚
â”‚                    /                                        â”‚
â”‚            â— project-2 â”€ â”€ â”€ â—‹ idea-6                     â”‚
â”‚           /        \                                        â”‚
â”‚   â—‰ business-1      â—‹ idea-7                              â”‚
â”‚    \      \                                                 â”‚
â”‚     \      â— project-3                                     â”‚
â”‚      \    /         \                                       â”‚
â”‚       â—‹ idea-1      â—‹ idea-8                              â”‚
â”‚        \                                                    â”‚
â”‚         â—‹ idea-2 â”€ â”€ â”€ â—‹ idea-9                          â”‚
â”‚                                                             â”‚
â”‚  Legend:                                                    â”‚
â”‚  â—‹ Stock  â— Build  â—‰ Measure/Learn  â—‡ Archive            â”‚
â”‚  â”€â”€â”€ Dependency  â”€ â”€ Inspiration  Â·Â·Â· Similar             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ãƒãƒ¼ãƒ‰è©³ç´°ãƒ‘ãƒãƒ«ï¼ˆã‚µã‚¤ãƒ‰ãƒãƒ¼ï¼‰
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ AI Assistant MVP â”‚
â”‚ â—‰ Measure Stage  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Connections: 5   â”‚
â”‚ â”œâ”€ Built from:   â”‚
â”‚ â”‚  â”” idea-1      â”‚
â”‚ â”œâ”€ Inspired:     â”‚
â”‚ â”‚  â”œ idea-6      â”‚
â”‚ â”‚  â”” idea-7      â”‚
â”‚ â””â”€ Related:      â”‚
â”‚    â”” project-3   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ KPIs:            â”‚
â”‚ Users: 1,250     â”‚
â”‚ Revenue: $5,000  â”‚
â”‚ Retention: 85%   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Open Details]   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## TDDå®Ÿè£…ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼

### 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

#### RED
```typescript
// tests/setup/project.test.ts
import { describe, it, expect } from 'vitest';

describe('Project Setup', () => {
  it('should have SvelteKit configured', async () => {
    const config = await import('../vite.config.js');
    expect(config.default.plugins).toContainEqual(
      expect.objectContaining({ name: 'vite-plugin-svelte' })
    );
  });

  it('should have MobX store configured', () => {
    const { graphStore } = require('../src/stores/graph');
    expect(graphStore).toBeDefined();
    expect(graphStore.nodes).toBeDefined();
  });
});
```

#### GREEN
```bash
npm create svelte@latest parallel-lean-node-graph -- --template=skeleton --types=typescript
cd parallel-lean-node-graph
npm install mobx mobx-svelte three @react-three/fiber react-force-graph-3d
npm install antd-svelte superstruct
npm install -D vitest playwright @playwright/test
```

### 2. ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«å®Ÿè£…

#### RED
```typescript
// tests/models/graph.test.ts
import { describe, it, expect } from 'vitest';
import * as s from 'superstruct';
import { NodeStruct, EdgeStruct, validateGraph } from '$lib/models/graph';

describe('Graph Models', () => {
  it('should validate node structure', () => {
    const validNode = {
      id: 'node-1',
      type: 'idea',
      label: 'AI Assistant',
      stage: 'stock',
      position: { x: 0, y: 0, z: 0 },
      data: {
        description: 'An AI that helps with daily tasks',
        createdAt: new Date().toISOString(),
        connections: {
          dependencies: [],
          inspirations: [],
          similar: []
        }
      }
    };
    
    expect(() => s.assert(validNode, NodeStruct)).not.toThrow();
  });

  it('should validate edge structure', () => {
    const validEdge = {
      id: 'edge-1',
      source: 'node-1',
      target: 'node-2',
      type: 'dependency',
      strength: 1.0
    };
    
    expect(() => s.assert(validEdge, EdgeStruct)).not.toThrow();
  });

  it('should detect graph cycles', () => {
    const nodes = [
      { id: '1', type: 'idea' },
      { id: '2', type: 'project' },
      { id: '3', type: 'project' }
    ];
    
    const edges = [
      { source: '1', target: '2' },
      { source: '2', target: '3' },
      { source: '3', target: '1' } // Creates cycle
    ];
    
    const validation = validateGraph(nodes, edges);
    expect(validation.hasCycles).toBe(true);
  });
});
```

#### GREEN
```typescript
// src/lib/models/graph.ts
import * as s from 'superstruct';

export const Position3D = s.object({
  x: s.number(),
  y: s.number(),
  z: s.number()
});

export const NodeStruct = s.object({
  id: s.string(),
  type: s.enums(['idea', 'project', 'business', 'archive']),
  label: s.string(),
  stage: s.enums(['stock', 'build', 'measure', 'learn', 'archive']),
  position: Position3D,
  data: s.object({
    description: s.optional(s.string()),
    createdAt: s.string(),
    updatedAt: s.optional(s.string()),
    connections: s.object({
      dependencies: s.array(s.string()),
      inspirations: s.array(s.string()),
      similar: s.array(s.string())
    }),
    metrics: s.optional(s.object({
      users: s.number(),
      revenue: s.number(),
      retention: s.number()
    }))
  })
});

export const EdgeStruct = s.object({
  id: s.string(),
  source: s.string(),
  target: s.string(),
  type: s.enums(['dependency', 'inspiration', 'similarity']),
  strength: s.number()
});

export type Node = s.Infer<typeof NodeStruct>;
export type Edge = s.Infer<typeof EdgeStruct>;

export interface GraphValidation {
  isValid: boolean;
  hasCycles: boolean;
  orphanNodes: string[];
  errors: string[];
}

export function validateGraph(nodes: Node[], edges: Edge[]): GraphValidation {
  const validation: GraphValidation = {
    isValid: true,
    hasCycles: false,
    orphanNodes: [],
    errors: []
  };

  // Check for cycles using DFS
  const adjacencyList = new Map<string, string[]>();
  edges.forEach(edge => {
    if (!adjacencyList.has(edge.source)) {
      adjacencyList.set(edge.source, []);
    }
    adjacencyList.get(edge.source)!.push(edge.target);
  });

  const visited = new Set<string>();
  const recursionStack = new Set<string>();

  function hasCycle(node: string): boolean {
    visited.add(node);
    recursionStack.add(node);

    const neighbors = adjacencyList.get(node) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        if (hasCycle(neighbor)) return true;
      } else if (recursionStack.has(neighbor)) {
        return true;
      }
    }

    recursionStack.delete(node);
    return false;
  }

  // Check each node for cycles
  for (const node of nodes) {
    if (!visited.has(node.id) && hasCycle(node.id)) {
      validation.hasCycles = true;
      validation.errors.push(`Cycle detected involving node ${node.id}`);
      break;
    }
  }

  // Find orphan nodes
  const connectedNodes = new Set<string>();
  edges.forEach(edge => {
    connectedNodes.add(edge.source);
    connectedNodes.add(edge.target);
  });

  validation.orphanNodes = nodes
    .filter(node => !connectedNodes.has(node.id))
    .map(node => node.id);

  validation.isValid = !validation.hasCycles && validation.errors.length === 0;
  return validation;
}
```

### 3. MobX Storeå®Ÿè£…

#### RED
```typescript
// tests/stores/graph.test.ts
import { describe, it, expect } from 'vitest';
import { graphStore, GraphStore } from '$lib/stores/graph';

describe('Graph Store', () => {
  beforeEach(() => {
    graphStore.reset();
  });

  it('should add nodes', () => {
    const node = graphStore.addNode({
      type: 'idea',
      label: 'Test Idea',
      stage: 'stock'
    });
    
    expect(graphStore.nodes.length).toBe(1);
    expect(node.id).toBeDefined();
    expect(node.position).toBeDefined();
  });

  it('should create edges between nodes', () => {
    const node1 = graphStore.addNode({ type: 'idea', label: 'Idea 1' });
    const node2 = graphStore.addNode({ type: 'project', label: 'Project 1' });
    
    const edge = graphStore.connectNodes(node1.id, node2.id, 'dependency');
    
    expect(graphStore.edges.length).toBe(1);
    expect(edge.type).toBe('dependency');
  });

  it('should apply force simulation', () => {
    // Add multiple nodes
    for (let i = 0; i < 5; i++) {
      graphStore.addNode({ type: 'idea', label: `Idea ${i}` });
    }
    
    const initialPositions = graphStore.nodes.map(n => ({ ...n.position }));
    
    // Run simulation
    graphStore.runSimulation(100);
    
    // Check that positions changed
    const hasMovement = graphStore.nodes.some((node, i) => 
      node.position.x !== initialPositions[i].x ||
      node.position.y !== initialPositions[i].y
    );
    
    expect(hasMovement).toBe(true);
  });

  it('should filter nodes by stage', () => {
    graphStore.addNode({ type: 'idea', stage: 'stock' });
    graphStore.addNode({ type: 'project', stage: 'build' });
    graphStore.addNode({ type: 'business', stage: 'measure' });
    
    const filtered = graphStore.getNodesByStage('build');
    expect(filtered.length).toBe(1);
    expect(filtered[0].stage).toBe('build');
  });
});
```

#### GREEN
```typescript
// src/lib/stores/graph.ts
import { makeAutoObservable, action, computed } from 'mobx';
import { Node, Edge } from '$lib/models/graph';
import * as THREE from 'three';

export class GraphStore {
  nodes: Node[] = [];
  edges: Edge[] = [];
  selectedNodeId: string | null = null;
  viewSettings = {
    showLabels: true,
    showEdges: true,
    zoomLevel: 1,
    rotation: { x: 0, y: 0 }
  };

  constructor() {
    makeAutoObservable(this);
  }

  @action
  addNode(data: Partial<Node>): Node {
    const node: Node = {
      id: `node-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type: data.type || 'idea',
      label: data.label || 'New Node',
      stage: data.stage || 'stock',
      position: data.position || this.generateRandomPosition(),
      data: {
        createdAt: new Date().toISOString(),
        connections: {
          dependencies: [],
          inspirations: [],
          similar: []
        },
        ...data.data
      }
    };

    this.nodes.push(node);
    return node;
  }

  @action
  connectNodes(sourceId: string, targetId: string, type: Edge['type']): Edge {
    const edge: Edge = {
      id: `edge-${Date.now()}`,
      source: sourceId,
      target: targetId,
      type,
      strength: type === 'dependency' ? 1.0 : 0.5
    };

    this.edges.push(edge);

    // Update node connections
    const sourceNode = this.nodes.find(n => n.id === sourceId);
    const targetNode = this.nodes.find(n => n.id === targetId);
    
    if (sourceNode && targetNode) {
      const connectionType = type === 'dependency' ? 'dependencies' : 
                           type === 'inspiration' ? 'inspirations' : 'similar';
      sourceNode.data.connections[connectionType].push(targetId);
    }

    return edge;
  }

  @action
  updateNodePosition(nodeId: string, position: { x: number; y: number; z: number }) {
    const node = this.nodes.find(n => n.id === nodeId);
    if (node) {
      node.position = position;
    }
  }

  @action
  selectNode(nodeId: string | null) {
    this.selectedNodeId = nodeId;
  }

  @computed
  get selectedNode(): Node | null {
    return this.nodes.find(n => n.id === this.selectedNodeId) || null;
  }

  getNodesByStage(stage: Node['stage']): Node[] {
    return this.nodes.filter(n => n.stage === stage);
  }

  getConnectedNodes(nodeId: string): Node[] {
    const connectedIds = new Set<string>();
    
    // Find edges where this node is source or target
    this.edges.forEach(edge => {
      if (edge.source === nodeId) {
        connectedIds.add(edge.target);
      } else if (edge.target === nodeId) {
        connectedIds.add(edge.source);
      }
    });

    return this.nodes.filter(n => connectedIds.has(n.id));
  }

  @action
  runSimulation(iterations: number = 100) {
    // Simple force-directed layout simulation
    const k = 100; // Ideal spring length
    const c = 0.01; // Repulsion constant

    for (let iter = 0; iter < iterations; iter++) {
      // Calculate repulsive forces
      for (let i = 0; i < this.nodes.length; i++) {
        for (let j = i + 1; j < this.nodes.length; j++) {
          const nodeA = this.nodes[i];
          const nodeB = this.nodes[j];
          
          const dx = nodeB.position.x - nodeA.position.x;
          const dy = nodeB.position.y - nodeA.position.y;
          const dz = nodeB.position.z - nodeA.position.z;
          const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
          
          if (distance > 0) {
            const force = (c * k * k) / distance;
            const fx = (dx / distance) * force;
            const fy = (dy / distance) * force;
            const fz = (dz / distance) * force;
            
            nodeA.position.x -= fx;
            nodeA.position.y -= fy;
            nodeA.position.z -= fz;
            nodeB.position.x += fx;
            nodeB.position.y += fy;
            nodeB.position.z += fz;
          }
        }
      }

      // Calculate attractive forces for edges
      this.edges.forEach(edge => {
        const source = this.nodes.find(n => n.id === edge.source);
        const target = this.nodes.find(n => n.id === edge.target);
        
        if (source && target) {
          const dx = target.position.x - source.position.x;
          const dy = target.position.y - source.position.y;
          const dz = target.position.z - source.position.z;
          const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
          
          if (distance > 0) {
            const force = (distance * distance) / k * edge.strength;
            const fx = (dx / distance) * force * 0.01;
            const fy = (dy / distance) * force * 0.01;
            const fz = (dz / distance) * force * 0.01;
            
            source.position.x += fx;
            source.position.y += fy;
            source.position.z += fz;
            target.position.x -= fx;
            target.position.y -= fy;
            target.position.z -= fz;
          }
        }
      });
    }
  }

  private generateRandomPosition() {
    return {
      x: (Math.random() - 0.5) * 200,
      y: (Math.random() - 0.5) * 200,
      z: (Math.random() - 0.5) * 100
    };
  }

  @action
  reset() {
    this.nodes = [];
    this.edges = [];
    this.selectedNodeId = null;
  }
}

export const graphStore = new GraphStore();
```

### 4. 3Dã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå®Ÿè£…

#### RED
```typescript
// tests/components/GraphView.test.ts
import { describe, it, expect } from '@playwright/test';

describe('GraphView Component', () => {
  test('should render 3D graph canvas', async ({ page }) => {
    await page.goto('/');
    
    const canvas = await page.locator('canvas');
    expect(await canvas.isVisible()).toBe(true);
  });

  test('should handle node click', async ({ page }) => {
    await page.goto('/');
    
    // Add a node
    await page.click('button:has-text("+ Node")');
    
    // Click on the node (simulate canvas click)
    const canvas = await page.locator('canvas');
    await canvas.click({ position: { x: 400, y: 300 } });
    
    // Check if node detail panel appears
    const detailPanel = await page.locator('.node-detail-panel');
    expect(await detailPanel.isVisible()).toBe(true);
  });

  test('should support zoom and pan', async ({ page }) => {
    await page.goto('/');
    
    const canvas = await page.locator('canvas');
    
    // Zoom in
    await canvas.hover();
    await page.mouse.wheel(0, -100);
    
    // Pan
    await canvas.dragTo(canvas, {
      sourcePosition: { x: 400, y: 300 },
      targetPosition: { x: 500, y: 400 }
    });
    
    // Verify view changed (check transform matrix or camera position)
    const viewState = await page.evaluate(() => {
      return window.graphViewState;
    });
    
    expect(viewState.zoom).toBeGreaterThan(1);
  });
});
```

#### GREEN
```svelte
<!-- src/lib/components/GraphView.svelte -->
<script lang="ts">
  import { onMount } from 'svelte';
  import { observer } from 'mobx-svelte';
  import ForceGraph3D from 'react-force-graph-3d';
  import { graphStore } from '$lib/stores/graph';

  let containerEl: HTMLDivElement;
  let graphInstance: any;

  const graphData = $: ({
    nodes: graphStore.nodes.map(node => ({
      id: node.id,
      name: node.label,
      val: node.type === 'business' ? 20 : node.type === 'project' ? 15 : 10,
      color: getNodeColor(node.stage),
      ...node.position
    })),
    links: graphStore.edges.map(edge => ({
      source: edge.source,
      target: edge.target,
      value: edge.strength,
      color: getEdgeColor(edge.type)
    }))
  });

  function getNodeColor(stage: string): string {
    const colors = {
      stock: '#FFFFFF',
      build: '#E0E0E0',
      measure: '#333333',
      learn: '#666666',
      archive: '#C0C0C0'
    };
    return colors[stage] || '#FFFFFF';
  }

  function getEdgeColor(type: string): string {
    const colors = {
      dependency: '#000000',
      inspiration: '#666666',
      similarity: '#C0C0C0'
    };
    return colors[type] || '#999999';
  }

  function handleNodeClick(node: any) {
    graphStore.selectNode(node.id);
  }

  function handleNodeDrag(node: any) {
    graphStore.updateNodePosition(node.id, {
      x: node.x,
      y: node.y,
      z: node.z
    });
  }

  onMount(() => {
    // Initialize 3D graph
    if (typeof window !== 'undefined') {
      import('react-force-graph-3d').then(({ default: ForceGraph3D }) => {
        graphInstance = ForceGraph3D()(containerEl)
          .graphData(graphData)
          .nodeLabel('name')
          .nodeColor('color')
          .nodeVal('val')
          .linkColor('color')
          .linkWidth(link => link.value * 2)
          .linkDirectionalParticles(2)
          .linkDirectionalParticleSpeed(0.005)
          .onNodeClick(handleNodeClick)
          .onNodeDragEnd(handleNodeDrag)
          .backgroundColor('#FAFAFA')
          .showNavInfo(false);

        // Custom node rendering
        graphInstance.nodeThreeObject(node => {
          const geometry = new THREE.SphereGeometry(node.val / 2);
          const material = new THREE.MeshBasicMaterial({
            color: node.color,
            wireframe: true
          });
          return new THREE.Mesh(geometry, material);
        });

        // Store view state for testing
        window.graphViewState = {
          zoom: 1,
          center: { x: 0, y: 0, z: 0 }
        };
      });
    }

    return () => {
      if (graphInstance) {
        graphInstance._destructor();
      }
    };
  });
</script>

<div class="graph-container" bind:this={containerEl}>
  <!-- 3D Graph renders here -->
</div>

<style>
  .graph-container {
    width: 100%;
    height: 100%;
    background-color: #FAFAFA;
    position: relative;
  }

  :global(.graph-tooltip) {
    font-family: 'Silka-Mono', monospace;
    background-color: white;
    border: 1px solid #000;
    padding: 8px;
    font-size: 12px;
  }
</style>
```

### 5. ãƒãƒ¼ãƒ‰è©³ç´°ãƒ‘ãƒãƒ«å®Ÿè£…

#### RED
```typescript
// tests/components/NodeDetailPanel.test.ts
import '@testing-library/jest-dom';
import { render } from '@testing-library/svelte';
import NodeDetailPanel from '$lib/components/NodeDetailPanel.svelte';
import { graphStore } from '$lib/stores/graph';

describe('NodeDetailPanel', () => {
  it('should display node information', () => {
    const node = {
      id: '1',
      label: 'Test Node',
      type: 'project',
      stage: 'build',
      data: {
        connections: {
          dependencies: ['node-0'],
          inspirations: ['node-2', 'node-3'],
          similar: []
        },
        metrics: {
          users: 1250,
          revenue: 5000,
          retention: 85
        }
      }
    };

    graphStore.nodes = [node];
    graphStore.selectedNodeId = '1';

    const { getByText } = render(NodeDetailPanel);

    expect(getByText('Test Node')).toBeInTheDocument();
    expect(getByText('â— Build Stage')).toBeInTheDocument();
    expect(getByText('Connections: 3')).toBeInTheDocument();
    expect(getByText('Users: 1,250')).toBeInTheDocument();
  });
});
```

#### GREEN
```svelte
<!-- src/lib/components/NodeDetailPanel.svelte -->
<script lang="ts">
  import { observer } from 'mobx-svelte';
  import { graphStore } from '$lib/stores/graph';
  import { Button, Card, Statistic, Tag } from 'antd-svelte';

  $: selectedNode = graphStore.selectedNode;
  $: connections = selectedNode ? graphStore.getConnectedNodes(selectedNode.id) : [];
  $: totalConnections = selectedNode ? 
    selectedNode.data.connections.dependencies.length +
    selectedNode.data.connections.inspirations.length +
    selectedNode.data.connections.similar.length : 0;

  function getStageIcon(stage: string) {
    const icons = {
      stock: 'â—‹',
      build: 'â—',
      measure: 'â—‰',
      learn: 'â—‰',
      archive: 'â—‡'
    };
    return icons[stage] || 'â—‹';
  }

  function formatNumber(num: number): string {
    return new Intl.NumberFormat().format(num);
  }
</script>

{#if selectedNode}
  <div class="detail-panel">
    <Card bordered={false}>
      <h3>{selectedNode.label}</h3>
      <Tag color="black">
        {getStageIcon(selectedNode.stage)} {selectedNode.stage} Stage
      </Tag>
      
      <div class="connections">
        <h4>Connections: {totalConnections}</h4>
        
        {#if selectedNode.data.connections.dependencies.length > 0}
          <div class="connection-group">
            <span class="label">Built from:</span>
            {#each selectedNode.data.connections.dependencies as dep}
              <div class="connection-item">â”” {dep}</div>
            {/each}
          </div>
        {/if}
        
        {#if selectedNode.data.connections.inspirations.length > 0}
          <div class="connection-group">
            <span class="label">Inspired:</span>
            {#each selectedNode.data.connections.inspirations as insp}
              <div class="connection-item">â”œ {insp}</div>
            {/each}
          </div>
        {/if}
      </div>
      
      {#if selectedNode.data.metrics}
        <div class="metrics">
          <h4>KPIs:</h4>
          <Statistic 
            title="Users" 
            value={formatNumber(selectedNode.data.metrics.users)} 
          />
          <Statistic 
            title="Revenue" 
            value={`$${formatNumber(selectedNode.data.metrics.revenue)}`} 
          />
          <Statistic 
            title="Retention" 
            value={`${selectedNode.data.metrics.retention}%`} 
          />
        </div>
      {/if}
      
      <Button type="primary" block>Open Details</Button>
    </Card>
  </div>
{/if}

<style>
  .detail-panel {
    position: fixed;
    right: 20px;
    top: 80px;
    width: 300px;
    background: white;
    border: 1px solid #000;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    font-family: 'Silka-Mono', monospace;
  }

  h3 {
    font-size: 16px;
    margin-bottom: 12px;
  }

  h4 {
    font-size: 14px;
    margin: 16px 0 8px;
  }

  .connections {
    margin: 16px 0;
  }

  .connection-group {
    margin: 8px 0;
  }

  .label {
    font-size: 12px;
    color: #666;
  }

  .connection-item {
    font-size: 12px;
    margin-left: 16px;
    color: #333;
  }

  .metrics {
    margin: 16px 0;
  }

  :global(.ant-statistic) {
    margin-bottom: 12px;
  }

  :global(.ant-statistic-title) {
    font-family: 'Silka-Mono', monospace;
    font-size: 12px;
  }

  :global(.ant-statistic-content) {
    font-family: 'Silka-Mono', monospace;
  }
</style>
```

### 6. ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆå®Ÿè£…

```svelte
<!-- src/routes/+page.svelte -->
<script lang="ts">
  import { observer } from 'mobx-svelte';
  import GraphView from '$lib/components/GraphView.svelte';
  import NodeDetailPanel from '$lib/components/NodeDetailPanel.svelte';
  import ControlPanel from '$lib/components/ControlPanel.svelte';
  import { graphStore } from '$lib/stores/graph';
  import { Layout, Menu, Input, Button, Dropdown } from 'antd-svelte';

  const { Header, Content } = Layout;
  const { Search } = Input;

  let searchValue = '';

  const viewOptions = [
    { key: 'all', label: 'All Nodes' },
    { key: 'active', label: 'Active Only' },
    { key: 'connections', label: 'Show Connections' }
  ];

  function handleAddNode() {
    graphStore.addNode({
      label: `Idea ${graphStore.nodes.length + 1}`,
      type: 'idea',
      stage: 'stock'
    });
  }

  function handleSearch(value: string) {
    // Implement search functionality
    console.log('Searching for:', value);
  }
</script>

<Layout class="layout">
  <Header class="header">
    <div class="header-content">
      <h1>ParallelLean</h1>
      <div class="controls">
        <Dropdown menu={{ items: viewOptions }}>
          <Button>âš™ï¸ View â–¼</Button>
        </Dropdown>
        <Search
          placeholder="ğŸ” Search"
          bind:value={searchValue}
          onSearch={handleSearch}
          style="width: 200px"
        />
        <Button type="primary" onClick={handleAddNode}>
          + Node
        </Button>
      </div>
    </div>
  </Header>
  
  <Content class="content">
    <GraphView />
    <NodeDetailPanel />
    
    <div class="legend">
      <span>â—‹ Stock</span>
      <span>â— Build</span>
      <span>â—‰ Measure/Learn</span>
      <span>â—‡ Archive</span>
      <div class="separator"></div>
      <span>â”€â”€â”€ Dependency</span>
      <span>â”€ â”€ Inspiration</span>
      <span>Â·Â·Â· Similar</span>
    </div>
  </Content>
</Layout>

<style>
  :global(.layout) {
    height: 100vh;
    font-family: 'Silka-Mono', monospace;
  }

  :global(.header) {
    background: #ffffff;
    border-bottom: 1px solid #000;
    padding: 0 24px;
  }

  .header-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
    height: 64px;
  }

  h1 {
    margin: 0;
    font-size: 20px;
    font-weight: 600;
  }

  .controls {
    display: flex;
    gap: 16px;
    align-items: center;
  }

  :global(.content) {
    position: relative;
    height: calc(100vh - 64px);
    background: #fafafa;
  }

  .legend {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: white;
    border: 1px solid #000;
    padding: 12px 16px;
    font-size: 12px;
    display: flex;
    gap: 16px;
    align-items: center;
  }

  .separator {
    width: 1px;
    height: 16px;
    background: #ccc;
    margin: 0 8px;
  }
</style>
```

### 7. E2Eãƒ†ã‚¹ãƒˆå®Ÿè£…

```typescript
// tests/e2e/node-graph.spec.ts
import { test, expect } from '@playwright/test';

test.describe('Node Graph UI', () => {
  test('should create and connect nodes', async ({ page }) => {
    await page.goto('/');
    
    // Create first node
    await page.click('button:has-text("+ Node")');
    await page.waitForTimeout(500);
    
    // Create second node
    await page.click('button:has-text("+ Node")');
    await page.waitForTimeout(500);
    
    // Connect nodes (via context menu or drag)
    const canvas = page.locator('canvas');
    await canvas.click({ position: { x: 400, y: 300 }, button: 'right' });
    await page.click('text=Connect to...');
    
    // Verify connection
    const edges = await page.evaluate(() => {
      return window.graphStore.edges.length;
    });
    expect(edges).toBeGreaterThan(0);
  });

  test('should filter nodes by stage', async ({ page }) => {
    await page.goto('/');
    
    // Add nodes with different stages
    for (let i = 0; i < 5; i++) {
      await page.click('button:has-text("+ Node")');
    }
    
    // Apply filter
    await page.click('button:has-text("View")');
    await page.click('text=Active Only');
    
    // Verify filtered view
    const visibleNodes = await page.evaluate(() => {
      return document.querySelectorAll('.node-visible').length;
    });
    expect(visibleNodes).toBeLessThan(5);
  });

  test('should save and load graph state', async ({ page }) => {
    await page.goto('/');
    
    // Create some nodes
    await page.click('button:has-text("+ Node")');
    await page.click('button:has-text("+ Node")');
    
    // Save state
    await page.keyboard.press('Control+S');
    
    // Reload page
    await page.reload();
    
    // Verify nodes persisted
    const nodes = await page.evaluate(() => {
      return window.graphStore.nodes.length;
    });
    expect(nodes).toBe(2);
  });
});
```

## ãƒ‡ãƒ—ãƒ­ã‚¤è¨­å®š

### Vercelè¨­å®š
```json
{
  "buildCommand": "npm run build",
  "outputDirectory": ".svelte-kit/output",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "sveltekit"
}
```

### Supabaseã‚¹ã‚­ãƒ¼ãƒ
```sql
-- ãƒãƒ¼ãƒ‰ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE nodes (
  id TEXT PRIMARY KEY,
  type TEXT NOT NULL,
  label TEXT NOT NULL,
  stage TEXT NOT NULL,
  position JSONB NOT NULL,
  data JSONB NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ã‚¨ãƒƒã‚¸ãƒ†ãƒ¼ãƒ–ãƒ«
CREATE TABLE edges (
  id TEXT PRIMARY KEY,
  source TEXT REFERENCES nodes(id) ON DELETE CASCADE,
  target TEXT REFERENCES nodes(id) ON DELETE CASCADE,
  type TEXT NOT NULL,
  strength FLOAT NOT NULL DEFAULT 1.0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
CREATE INDEX idx_nodes_stage ON nodes(stage);
CREATE INDEX idx_edges_source ON edges(source);
CREATE INDEX idx_edges_target ON edges(target);
```

## TDDãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆãƒã‚§ãƒƒã‚¯ãƒœãƒƒã‚¯ã‚¹å¼æ‰‹é †æ›¸ï¼‰

### Phase 1: SvelteKitç’°å¢ƒæ§‹ç¯‰
- [ ] **TODOãƒªã‚¹ãƒˆä½œæˆ**
  - [ ] ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ã®æ©Ÿèƒ½è¦ä»¶ã‚’ãƒªã‚¹ãƒˆã‚¢ãƒƒãƒ—
  - [ ] 3Dè¡¨ç¾ã®æŠ€è¡“çš„è¦ä»¶ã‚’æ•´ç†
  - [ ] ã‚¿ã‚¹ã‚¯ã‚’15åˆ†å˜ä½ã«åˆ†è§£

- [ ] **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆæœŸåŒ–**
  - [ ] `npm create svelte@latest`ã§SvelteKitãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
  - [ ] TypeScriptè¨­å®šã®ç¢ºèª
  - [ ] Vitestã®è¨­å®š
  - [ ] æœ€åˆã®ãƒ†ã‚¹ãƒˆï¼ˆè¨­å®šç¢ºèªï¼‰ã‚’ä½œæˆ
  - [ ] ãƒ†ã‚¹ãƒˆå¤±æ•—ã‚’ç¢ºèªï¼ˆREDï¼‰
  - [ ] è¨­å®šã‚’è¿½åŠ ã—ã¦ãƒ†ã‚¹ãƒˆã‚’é€šã™ï¼ˆGREENï¼‰

### Phase 2: ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ãƒ¢ãƒ‡ãƒ«
- [ ] **Superstructã§ã®ãƒ¢ãƒ‡ãƒ«å®šç¾©ãƒ†ã‚¹ãƒˆ**
  - [ ] `tests/models/graph.test.ts`ã‚’ä½œæˆ
  - [ ] NodeStructã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] EdgeStructã®æ¤œè¨¼ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ã‚°ãƒ©ãƒ•å¾ªç’°æ¤œå‡ºã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆREDï¼‰

- [ ] **ãƒ¢ãƒ‡ãƒ«ã®æ®µéšçš„å®Ÿè£…**
  - [ ] åŸºæœ¬çš„ãªNodeå‹ã‚’å®šç¾©ï¼ˆä»®å®Ÿè£…ï¼‰
  - [ ] 3Dåº§æ¨™ã‚’å«ã‚€å‹ã«æ‹¡å¼µ
  - [ ] Edgeå‹ã‚’å®šç¾©
  - [ ] ã‚°ãƒ©ãƒ•ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³é–¢æ•°ã‚’å®Ÿè£…
  - [ ] å¾ªç’°æ¤œå‡ºã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’è¿½åŠ 
  - [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆGREENï¼‰

### Phase 3: MobXã‚¹ãƒˆã‚¢å®Ÿè£…
- [ ] **ã‚°ãƒ©ãƒ•ã‚¹ãƒˆã‚¢ã®ãƒ†ã‚¹ãƒˆä½œæˆ**
  - [ ] `tests/stores/graph.test.ts`ã‚’ä½œæˆ
  - [ ] ãƒãƒ¼ãƒ‰è¿½åŠ ã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ã‚¨ãƒƒã‚¸ä½œæˆã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ç‰©ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ãƒ†ã‚¹ãƒˆå¤±æ•—ã‚’ç¢ºèªï¼ˆREDï¼‰

- [ ] **ã‚¹ãƒˆã‚¢ã®å®Ÿè£…**
  - [ ] åŸºæœ¬çš„ãªMobXã‚¹ãƒˆã‚¢ã‚’ä½œæˆ
  - [ ] addNodeãƒ¡ã‚½ãƒƒãƒ‰ã®ä»®å®Ÿè£…
  - [ ] æœ€åˆã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèª
  - [ ] connectNodesãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…
  - [ ] ä½ç½®æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ã‚’è¿½åŠ 
  - [ ] Force-directedã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’å®Ÿè£…
  - [ ] ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼‰

### Phase 4: 3Dã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼å®Ÿè£…
- [ ] **GraphViewã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ**
  - [ ] Playwrightã§ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ†ã‚¹ãƒˆä½œæˆ
  - [ ] ã‚­ãƒ£ãƒ³ãƒã‚¹è¡¨ç¤ºã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ãƒãƒ¼ãƒ‰ã‚¯ãƒªãƒƒã‚¯ã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ã‚ºãƒ¼ãƒ /ãƒ‘ãƒ³æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] ãƒ†ã‚¹ãƒˆå¤±æ•—ã‚’ç¢ºèªï¼ˆREDï¼‰

- [ ] **Three.jsçµ±åˆ**
  - [ ] åŸºæœ¬çš„ãªcanvasè¦ç´ ã‚’é…ç½®
  - [ ] Three.jsã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
  - [ ] ãƒãƒ¼ãƒ‰ã‚’çƒä½“ã¨ã—ã¦æç”»
  - [ ] ã‚¨ãƒƒã‚¸ã‚’ç·šã¨ã—ã¦æç”»
  - [ ] ã‚«ãƒ¡ãƒ©ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã‚’è¿½åŠ 
  - [ ] ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã‚’å®Ÿè£…
  - [ ] å„ã‚¹ãƒ†ãƒƒãƒ—ã§ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ

### Phase 5: Svelteã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆå®Ÿè£…
- [ ] **ãƒãƒ¼ãƒ‰è©³ç´°ãƒ‘ãƒãƒ«ã®ãƒ†ã‚¹ãƒˆ**
  - [ ] ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆãƒ†ã‚¹ãƒˆã‚’ä½œæˆ
  - [ ] ãƒãƒ¼ãƒ‰æƒ…å ±è¡¨ç¤ºã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] æ¥ç¶šæƒ…å ±è¡¨ç¤ºã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã
  - [ ] KPIè¡¨ç¤ºã®ãƒ†ã‚¹ãƒˆã‚’æ›¸ã

- [ ] **UIã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã®å®Ÿè£…**
  - [ ] åŸºæœ¬çš„ãªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ä½œæˆ
  - [ ] Ant Designçµ±åˆï¼ˆantd-svelteï¼‰
  - [ ] ã‚¹ãƒˆã‚¢ã¨ã®ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
  - [ ] ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ›´æ–°ã®å®Ÿè£…
  - [ ] ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°ï¼ˆç™½é»’ãƒ†ãƒ¼ãƒï¼‰

### Phase 6: ã‚°ãƒ©ãƒ•æ“ä½œæ©Ÿèƒ½
- [ ] **ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³æ©Ÿèƒ½ã®ãƒ†ã‚¹ãƒˆ**
  - [ ] ãƒ‰ãƒ©ãƒƒã‚°æ“ä½œã®ãƒ†ã‚¹ãƒˆ
  - [ ] å³ã‚¯ãƒªãƒƒã‚¯ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
  - [ ] ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã®ãƒ†ã‚¹ãƒˆ

- [ ] **æ©Ÿèƒ½å®Ÿè£…**
  - [ ] ãƒãƒ¼ãƒ‰ã®ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—
  - [ ] ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒ‹ãƒ¥ãƒ¼
  - [ ] æ¤œç´¢æ©Ÿèƒ½
  - [ ] ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°æ©Ÿèƒ½
  - [ ] ãƒ“ãƒ¥ãƒ¼ã®ä¿å­˜/èª­ã¿è¾¼ã¿

### Phase 7: ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³æœ€é©åŒ–
- [ ] **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ**
  - [ ] 1000ãƒãƒ¼ãƒ‰ã§ã®FPSæ¸¬å®šãƒ†ã‚¹ãƒˆ
  - [ ] ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®æ¸¬å®š
  - [ ] ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æœ€é©åŒ–ã®ãƒ†ã‚¹ãƒˆ

- [ ] **æœ€é©åŒ–å®Ÿè£…**
  - [ ] Web Workerã§ã®ç‰©ç†æ¼”ç®—
  - [ ] LODï¼ˆLevel of Detailï¼‰å®Ÿè£…
  - [ ] ä»®æƒ³åŒ–ï¼ˆè¦–ç•Œå¤–ãƒãƒ¼ãƒ‰ã®éè¡¨ç¤ºï¼‰
  - [ ] ãƒãƒƒãƒãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  - [ ] GPUæœ€é©åŒ–

### Phase 8: SvelteKitç‰¹æœ‰ã®æ©Ÿèƒ½
- [ ] **SSR/ãƒã‚¤ãƒ‰ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¯¾å¿œ**
  - [ ] SSRæ™‚ã®Three.jså‡¦ç†ãƒ†ã‚¹ãƒˆ
  - [ ] ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚µã‚¤ãƒ‰ãƒã‚¤ãƒ‰ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ
  - [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãƒ†ã‚¹ãƒˆ

- [ ] **å®Ÿè£…**
  - [ ] ãƒ–ãƒ©ã‚¦ã‚¶ç’°å¢ƒãƒã‚§ãƒƒã‚¯
  - [ ] å‹•çš„ã‚¤ãƒ³ãƒãƒ¼ãƒˆè¨­å®š
  - [ ] ãƒ—ãƒ­ã‚°ãƒ¬ãƒƒã‚·ãƒ–ã‚¨ãƒ³ãƒãƒ³ã‚¹ãƒ¡ãƒ³ãƒˆ
  - [ ] ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè£…

### Phase 9: E2Eãƒ†ã‚¹ãƒˆ
- [ ] **Playwrightã§ã®çµ±åˆãƒ†ã‚¹ãƒˆ**
  - [ ] ã‚°ãƒ©ãƒ•ä½œæˆãƒ•ãƒ­ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
  - [ ] ãƒãƒ¼ãƒ‰æ¥ç¶šãƒ•ãƒ­ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
  - [ ] ä¿å­˜/èª­ã¿è¾¼ã¿ãƒ•ãƒ­ãƒ¼ã®ãƒ†ã‚¹ãƒˆ
  - [ ] ã™ã¹ã¦ã®E2Eãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã™ã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆREDï¼‰

- [ ] **E2Eå®Ÿè£…**
  - [ ] åŸºæœ¬çš„ãªãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³
  - [ ] ã‚°ãƒ©ãƒ•æ“ä½œã‚·ãƒŠãƒªã‚ª
  - [ ] ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–ç¢ºèª
  - [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
  - [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèªï¼ˆGREENï¼‰

### Phase 10: Supabaseçµ±åˆ
- [ ] **ãƒ‡ãƒ¼ã‚¿æ°¸ç¶šåŒ–ã®ãƒ†ã‚¹ãƒˆ**
  - [ ] ãƒãƒ¼ãƒ‰ä¿å­˜ã®ãƒ†ã‚¹ãƒˆ
  - [ ] ã‚¨ãƒƒã‚¸ä¿å­˜ã®ãƒ†ã‚¹ãƒˆ
  - [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ åŒæœŸã®ãƒ†ã‚¹ãƒˆ

- [ ] **å®Ÿè£…**
  - [ ] Supabaseã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆè¨­å®š
  - [ ] CRUDæ“ä½œã®å®Ÿè£…
  - [ ] ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³
  - [ ] ç«¶åˆè§£æ±ºãƒ­ã‚¸ãƒƒã‚¯
  - [ ] ã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œ

### ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆ
å„ãƒ•ã‚§ãƒ¼ã‚ºå®Œäº†æ™‚ã«ç¢ºèªï¼š
- [ ] ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆãŒé€šã£ã¦ã„ã‚‹
- [ ] 1000ãƒãƒ¼ãƒ‰ã§60FPSã‚’ç¶­æŒ
- [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ãŒãªã„
- [ ] TypeScriptã‚¨ãƒ©ãƒ¼ãŒ0
- [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œ
- [ ] ã‚°ãƒ©ãƒ•ã®ä¿å­˜/èª­ã¿è¾¼ã¿ãŒæ­£å¸¸å‹•ä½œ

## ã¾ã¨ã‚

ã“ã®ãƒãƒ¼ãƒ‰å½¢å¼UIå®Ÿè£…ã¯ã€Obsidianã®ã‚°ãƒ©ãƒ•ãƒ“ãƒ¥ãƒ¼ã‹ã‚‰ã‚¤ãƒ³ã‚¹ãƒ”ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å¾—ãŸ3Dç©ºé–“ã§ã®ãƒãƒ¼ãƒ‰ã‚°ãƒ©ãƒ•è¡¨ç¾ã«ã‚ˆã‚Šã€ã‚¢ã‚¤ãƒ‡ã‚¢ã¨äº‹æ¥­ã®é–¢ä¿‚æ€§ã‚’ç›´æ„Ÿçš„ã«æ¢ç´¢ã§ãã¾ã™ã€‚SvelteKitã¨MobXã®çµ„ã¿åˆã‚ã›ã«ã‚ˆã‚Šã€ãƒªã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã§é«˜æ€§èƒ½ãªUIã‚’å®Ÿç¾ã—ã€Three.jsã«ã‚ˆã‚‹ç¾ã—ã„3Dãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æä¾›ã—ã¾ã™ã€‚ç™½é»’ã®ãƒ¢ãƒ€ãƒ³ãƒ‡ã‚¶ã‚¤ãƒ³ã‚’ç¶­æŒã—ãªãŒã‚‰ã€ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªä½“é¨“ã‚’å®Ÿç¾ã—ã¦ã„ã¾ã™ã€‚