## 2025-01-25 タスクノード操作の遅延問題の詳細分析

### 問題の詳細
タスクノードの作成・編集・削除で顕著な遅延（3-5秒程度）が発生。

### 根本原因の特定

#### 1. 二重更新の問題
- **ローカル更新**: GraphCanvas.tsx で `addNode()` を呼び出し
- **リアルタイム更新**: useGraphData.ts の Supabase Realtime サブスクリプションで再度 `addNode()` が呼ばれる
- 同じノードが2回追加される処理を防ぐロジックはあるが、処理自体は2回実行される

#### 2. 物理シミュレーションの再起動オーバーヘッド
- ノード追加時に `simulation.alpha(0.3).restart()` が呼ばれる
- 状態選択ノード表示時にも再起動される
- 各再起動時に全ノードの力計算が実行される（O(n²)の計算複雑度）

#### 3. 不要な位置更新の保存
- useNodePositionPersist.ts がすべてのノードの位置変更を即座にDBに保存
- 物理シミュレーション中は毎フレーム位置が変わるため、大量のUPDATEクエリが発生
- タスク作成時：初期位置設定 → シミュレーション → 位置更新の連続発生

#### 4. タスク作成キューの待機時間
- `taskCreationQueueRef` で順次実行を保証
- 前のタスク作成が完了するまで待機
- DB操作 + ストア更新 + シミュレーション再起動の全体が完了するまで次が実行されない

#### 5. 状態管理の非効率性
- Zustandストアで毎回新しい配列を作成（`[...state.nodes, node]`）
- 大量ノード時にパフォーマンス低下
- 複数のコンポーネントが再レンダリングされる

### 具体的な処理フロー（タスク作成時）

1. **handleAddTask** 呼び出し
2. キューで前のタスクを待機
3. **Supabase INSERT** （ノード）- 約200ms
4. **addNode()** でストア更新
5. **物理シミュレーション再起動**
6. **Supabase INSERT** （エッジ）- 約200ms  
7. **addEdge()** でストア更新
8. **物理シミュレーション再起動**（2回目）
9. **Realtime通知受信** - 約100ms
10. **addNode()** 再実行（重複チェックあり）
11. **位置更新の連続保存** - シミュレーション中

### 改善案

1. **楽観的更新の実装**
   - DBクエリを非同期で実行
   - UIは即座に更新
   - エラー時のみロールバック

2. **物理シミュレーションの最適化**
   - 再起動の頻度を減らす
   - デバウンスの実装
   - 新規ノードのみ計算する部分最適化

3. **位置保存の最適化**
   - シミュレーション完了後にのみ保存
   - デバウンスまたはスロットリングの実装

4. **Realtime重複の回避**
   - ローカル操作フラグの実装
   - 自分の操作によるRealtime通知を無視

5. **状態管理の最適化**
   - Immerの導入
   - 必要最小限の再レンダリング

この分析により、主要な遅延要因は「同期的なDB操作」「二重更新」「過剰な物理シミュレーション再起動」であることが判明。

### ノード操作遅延の詳細分析

**背景**: 楽観的更新削除後、ノードの作成・編集・削除で顕著な遅延が発生

**主要な遅延原因**（優先度順）:

1. **位置更新の過剰なDB保存**（500-2000ms）
   - 物理シミュレーション中、100ms間隔で位置をDBに保存
   - 100ノードで1秒間に最大1000回のUPDATEクエリ

2. **物理シミュレーションの二重再起動**（200ms）
   - ノード追加とエッジ追加で2回再起動
   - O(n²)の計算を毎回フルで実行

3. **Supabase APIレスポンス時間**（300-500ms）
   - ノードINSERT: 150-250ms
   - エッジINSERT: 150-250ms

4. **タスク作成キューの直列処理**（累積遅延）
   - 前の処理の完了を待つため、連続作成時に遅延が蓄積

5. **Realtime通知の二重処理**（50-150ms）
   - ローカル更新とRealtime通知で同じ処理を2回実行

**測定結果**: タスク1つの作成に約1.2秒〜3秒

**詳細分析**: `/docs/PERFORMANCE-ANALYSIS.md` に検証方法を含む完全な分析を記載

### 位置更新の過剰なDB保存問題の解決

**背景**: 物理シミュレーション中、毎フレームで位置をDBに保存していたため、最大のパフォーマンスボトルネックとなっていた

**解決策**: 1分間隔での定期保存に統一

**実装内容**:

1. **useNodePositionPersist フックの改修**
   - dirtyノードの追跡（Set使用）
   - 1分ごとの定期保存（setInterval）
   - バッチ更新でパフォーマンス向上
   - アンマウント時の未保存データ保存

2. **シンプルな実装**
   - ドラッグ操作も含めて全て1分ごとに保存
   - カスタムイベントリスナーを削除してコードを簡潔化

**技術的な詳細**:
- 保存頻度: 毎秒数千回 → 毎分1回（99.9%以上削減）
- Promise.allでバッチ更新を並列実行
- シンプルで保守しやすい実装

**効果**:
- DB負荷が99%以上削減
- ノード操作のレスポンスが大幅に改善
- コードがシンプルになり保守性向上
